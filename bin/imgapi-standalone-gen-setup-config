#!/opt/smartdc/imgapi/build/node/bin/node

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright 2020 Joyent, Inc.
 * Copyright 2022 MNX Cloud, Inc.
 */

/*
 * Generate config for a standalone IMGAPI setup.
 *
 * Usage (from within a standalone IMGAPI zone):
 *      imgapi-standalone-gen-setup-config >/data/imgapi/etc/imgapi.config.json
 *
 * This will emit JSON content on stdout that is suitable for a standalone
 * IMGAPI config file. It comes from rendering
 * "etc/standalone/imgapi.config.json.handlebars" with "setup config vars"
 * from the instance's metadata (i.e. from `mdata-get`). Typically the setup
 * config vars are given as arguments to `imgapi-standalone-create`, e.g.
 *
 *      /opt/smartdc/imgapi/bin/imgapi-standalone-create \
 *          -m mode=public -m serverName="SmartOS Public Images Repo" \
 *          ...
 */

var assert = require('assert-plus');
var forkExecWait = require('forkexec').forkExecWait;
var fs = require('fs');
var handlebars = require('handlebars');
var path = require('path');
var sshpk = require('sshpk');
var vasync = require('vasync');
var VError = require('verror').VError;


//---- globals

var NAME = path.basename(__filename);

var topDir = path.resolve(__dirname, '..');
var templatePath = path.resolve(topDir, 'etc', 'standalone',
        'imgapi.config.json.handlebars');

var setupConfigVars = [
    'mode',
    'channels',
    'serverName',
    'mantaUrl',
    'mantaInsecure',
    'mantaUser',
    'mantaBaseDir',

    // Not really a setup config var. It is set by setup.sh rather than being
    // a var that can be passed in via instance metadata at creation time.
    'instPubKey'
];


//---- internal support stuff

function forkExecWaitAndLog(opts, cb) {
    assert.arrayOfString(opts.argv, 'opts.argv');
    assert.object(opts.log, 'opts.log');
    forkExecWait({argv: opts.argv}, function (err, info) {
        opts.log.trace({argv: opts.argv, err: err, info: info}, 'forkExecWait');
        cb(err, info);
    });
}

/*
 * Get a metadata key, with a default. I.e. it is not an error if the key
 * is not found (`mdata-get` exits with status=1 for that case).
 */
function mdataGet(key, def, cb) {
    assert.string(key, 'key');
    assert.func(cb, 'cb');

    var KEY_NOT_FOUND_STATUS = 1;

    var argv = ['/usr/sbin/mdata-get', key];
    forkExecWait({argv: argv}, function (err, info) {
        if (err) {
            if (info.status === KEY_NOT_FOUND_STATUS) {
                cb(null, def);
            } else {
                cb(err);
            }
        } else {
            // `mdata-get` appends a single '\n'. Drop it.
            assert.ok(info.stdout.length > 0);
            assert.equal(info.stdout[info.stdout.length - 1], '\n');
            var val = info.stdout.slice(0, -1);
            cb(null, val);
        }
    });
}

function mainFinish(err) {
    if (err) {
        var exitStatus = err.exitStatus || 1;
        console.error('%s: error: %s', NAME, err.stack);

        // Use a soft exit (i.e. just set `process.exitCode`) if supported.
        var supportsProcessExitCode = true;
        var nodeVer = process.versions.node.split('.').map(Number);
        if (nodeVer[0] === 0 && nodeVer[1] <= 10) {
            supportsProcessExitCode = false;
        }
        if (supportsProcessExitCode) {
            process.exitCode = exitStatus;
        } else if (exitStatus !== 0) {
            process.exit(exitStatus);
        }
    }
}


//---- mainline

function main() {
    vasync.pipeline({arg: {}, funcs: [
        function loadTemplate(arg, next) {
            fs.readFile(templatePath, 'utf8', function (err, content) {
                arg.template = content;
                next(err);
            });
        },

        function gatherSetupConfig(arg, next) {
            arg.setupConfig = {};
            vasync.forEachPipeline({
                inputs: setupConfigVars,
                func: function getSetupConfigVar(key, nextVar) {
                    mdataGet(key, null, function (err, val) {
                        if (val !== null && val !== undefined) {
                            arg.setupConfig[key] = val;
                        }
                        nextVar(err);
                    });
                }
            }, next);
        },

        /*
         * If 'mantaUser' is in setup config, that indicates that we are setting
         * up to use a Manta (for file storage, for backups, for log upload).
         * We then need to fill in `mantaKey` and `mantaKeyId`: using the key
         * written to /data/imgapi/etc (generated by setup.sh).
         */
        function getMantaKeyAndKeyId(arg, next) {
            if (!arg.setupConfig.mantaUser) {
                next();
                return;
            }

            /*
             * `instPubKey` is set by setup.sh to the pubkey to use. The
             * pubkey comment is meant to be the keyname that we can use to
             * find the path to the privkey.
             */
            assert.string(arg.setupConfig.instPubKey,
                'arg.setupConfig.instPubKey');

            var pubKey = sshpk.parseKey(arg.setupConfig.instPubKey);
            arg.setupConfig.mantaKeyId
                = pubKey.fingerprint('sha256').toString();

            var privKeyPath = '/data/imgapi/etc/' + pubKey.comment
                + '.id_ecdsa';
            fs.exists(privKeyPath, function (exists) {
                if (!exists) {
                    next(new VError('expected IMGAPI instance private key '
                        + '"%s" does not exist', privKeyPath));
                } else {
                    arg.setupConfig.mantaKey = privKeyPath;
                    next();
                }
            });
        },

        /*
         * "channels" may be the special value "standard", which is
         * transformed to .../etc/standalone/standard-channels.json. These are
         * the channels used by updates.tritondatacenter.com.
         */
        function handleChannelsStandard(arg, next) {
            if (!arg.setupConfig.channels
                || arg.setupConfig.channels !== 'standard')
            {
                next();
                return;
            }

            var stdChansFile = path.resolve(topDir, 'etc', 'standalone',
                'standard-channels.json');
            fs.readFile(stdChansFile, {
                encoding: 'utf8'
            }, function (readErr, text) {
                if (readErr) {
                    next(readErr);
                    return;
                }
                arg.setupConfig.channels = text;
                next();
            });
        },

        function render(arg, next) {
            var compiled = handlebars.compile(arg.template);
            arg.rendered = compiled(arg.setupConfig);
            next();
        },
        function validateConfigIsJson(arg, next) {
            try {
                JSON.parse(arg.rendered);
            } catch (parseErr) {
                next(new VError(parseErr,
                    'rendered setup config is not valid JSON: %s',
                    JSON.stringify(arg.rendered)));
                return;
            }
            next();
        },
        function emit(arg, next) {
            process.stdout.write(arg.rendered);
        }
    ]}, mainFinish);
}

main();
